\documentclass{beamer}
\usepackage{color}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{minted}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}
\newunicodechar{Ñ}{\ensuremath{\mathcal{N}}}
\newunicodechar{ᵐ}{\ensuremath{^m}}
\newunicodechar{ᶜ}{\ensuremath{^c}}
\newunicodechar{ᶠ}{\ensuremath{^f}}

\title{Automatization in Lean}
\author{Damiano Testa}
\institute{University of Warwick}
\date{May 2nd, 2023}

\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
{Automation}

In the context of formalization of mathematics, the computer

\begin{itemize}
\item
  takes on repetitive tasks;
\item
  helps producing more complicated arguments, as it helps separating neatly different parts of the argument;
\item
  informs, ideally, the {\textbf{discovery}} of new mathematical results;
\item
  works {\emph{very well}} to detect unnecessary hypotheses
\end{itemize}

  > however, the resulting generality is often only useful to simplify {\emph{formalization}}, rather than {\emph{discovery}} of mathematics.


Currently, Machine Learning, Artificial Intelligence, Neural Networks and auto-formalizations are not yet really available, though there is lots of interest and steady progress on this front.
\end{frame}

\begin{frame}[fragile]{Tactics}

The first main ``automation'' tactics that you will likely run into are {\verb`library_search`} and {\verb`simp`}.

Really, {\emph{any}} tactic is a form of automation.

Tactics allow us to maintain an abstraction:

\begin{itemize}
\item
  we humans, think that we are talking about mathematical concepts,
\item
  the computer has its own internal representation for these same concepts.
\end{itemize}

Tactics bridge this gap: we do not even need to know what the computer's internal representation is: tactics handle the translation.
\end{frame}

\begin{frame}[fragile]{{\texttt{library\_search}}}

{\verb`mathlib`} is a massive repository.

It contains over 1 million lines of code and over 60 thousand lemmas.

Most of the basic\footnotemark lemmas are already available.

{\verb`library_search`} helps you find them!

\begin{minted}[mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\small]{Lean}
import tactic

example {a b c : ℕ} : a ^ (b + c) = a ^ b * a ^ c :=
by library_search

--  Try this: exact pow_add a b c
\end{minted}

\footnotetext{``Basic'' means {\emph{really}} basic, to a level that you may not even consider them ``lemmas''.}
\end{frame}

\begin{frame}[fragile]

I personally used {\verb`library_search`} constantly, when I had just started using Lean.

Later on, I became more familiar with {\verb`mathlib`}'s [naming convention](https://leanprover-community.github.io/contribute/naming.html) I now use {\verb`library_search`} more rarely.
\end{frame}

\begin{frame}[fragile]{{\texttt{simp}}}

As the name suggests, the {\verb`simp`}lifier tries to simplify a goal (or a target hypothesis).

\begin{minted}[mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\small]{Lean}
example {a b : ℤ} : - (-1 * a + 0 * b) = a * (1 + a * 0) :=
begin
  simp,
end
\end{minted}
Here, {\verb`simp`} used the lemmas

{\verb`neg_mul`}, {\verb`neg_neg`},

{\verb`add_zero`},

{\verb`one_mul`}, {\verb`mul_one`},

{\verb`mul_zero`}, {\verb`zero_mul`}.
\end{frame}

\begin{frame}[fragile]{{\texttt{simp}}-lemmas}

The lemmas that {\verb`simp`} uses are ``{\verb`simp`}-lemmas'': carefully selected lemmas to have, among others, two basic features
\begin{itemize}
\item
  they assert an equality or an iff;
\item
  the LHS {\emph{looks more complicated}} than the RHS.
\end{itemize}

\begin{minted}[mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\small]{Lean}
#print one_mul:   -- shortened output:      1 * a = a
#print zero_mul:  -- shortened output:      0 * a = 0
#print add_zero:  -- shortened output:      a + 0 = 0
#print neg_neg:   -- shortened output:       - -a = a
#print mul_zero:  -- shortened output:      a * 0 = 0
#print mul_one:   -- shortened output:      a * 1 = a
#print neg_mul:   -- shortened output:     -a * b = -(a * b)
\end{minted}

The asymmetry helps Lean: it only tries to apply the lemmas in the direction hard --> easy.

[Being a ``{\verb`simp`}-lemma'' is just something that you must communicate to Lean: there is no automated mechanism that makes Lean self-select which lemmas are {\verb`simp`}-lemmas.]
\end{frame}
\end{document}
