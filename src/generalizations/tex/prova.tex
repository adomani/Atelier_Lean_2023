\documentclass{beamer}
\usepackage{color}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{minted}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,       % false: boxed links; true: colored links
    linkcolor=blue,        % color of internal links
    citecolor=magenta,     % color of links to bibliography
    filecolor=green,       % color of file links
    urlcolor=purple        % color of external links
}

\usepackage{newunicodechar}
\newunicodechar{ℕ}{\ensuremath{\mathbb{N}}}
\newunicodechar{ℤ}{\ensuremath{\mathbb{Z}}}
\newunicodechar{Ñ}{\ensuremath{\mathcal{N}}}
\newunicodechar{ᵐ}{\ensuremath{^m}}
\newunicodechar{ᶜ}{\ensuremath{^c}}
\newunicodechar{ᶠ}{\ensuremath{^f}}

\title{Automatization in Lean}
\author{Damiano Testa}
\institute{University of Warwick}
\date{\\
\vspace{50pt}
RNTA mini symposium
\href{http://www.rnta.eu/7MSRNTA/lean.html}{Atelier Lean 2023}\\
\vspace{20pt}
May 2nd, 2023
}


\begin{document}

\frame{\titlepage}

\begin{frame}[fragile]
{Automation}

Computers take on repetitive tasks.
\bigskip

In the context of formalization of mathematics, the computer also

\begin{itemize}
\item
  helps producing more complicated arguments, as it separates neatly different parts of the argument;
\item
  informs, ideally, the {\textbf{discovery}} of new mathematical results;
\item
  detects {\emph{very well}} unnecessary hypotheses.
\end{itemize}

\smallskip
\[
  \left[ \;
  \makebox{\parbox{0.8\textwidth}{\small
  The resulting generality is often only useful to simplify {\emph{formalization}}, rather than {\emph{discovery}} of mathematics.
  }}
  \; \right]
\]
\bigskip

Currently, Machine Learning, Artificial Intelligence, Neural Networks and auto-formalizations are not yet really available.
\bigskip

There is lots of interest and steady progress on this front.
\end{frame}

\begin{frame}[fragile]{Tactics}

The first main ``automation'' tactics that you will likely run into are {\verb`library_search`} and {\verb`simp`}.
\bigskip

Really, {\emph{any}} tactic is a form of automation.
\bigskip

Tactics allow to maintain abstraction:

\begin{itemize}
\item
  we humans talk about mathematical concepts,
\item
  the computer has some representation for these concepts.
\end{itemize}

Tactics bridge this gap.
\bigskip

We do not even need to know what the computer's internal representation is: tactics handle the translation.
\end{frame}

\begin{frame}[fragile]{{\texttt{library\_search}}}

{\verb`mathlib`} is a massive repository: it contains
\begin{itemize}
\item
  over 1 million lines of code
\item
  over 60 thousand lemmas.
\end{itemize}

Most of the basic{\footnotemark} lemmas are already available.
\bigskip

{\verb`library_search`} helps you find them!

\footnotetext{``Basic'' may mean {\emph{really}} basic, to a level that you may not even consider them ``lemmas''.}
\end{frame}

\begin{frame}[fragile]

\begin{minted}[mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\small]{Lean}
import tactic

example {a b c : ℕ} : a ^ (b + c) = a ^ b * a ^ c :=
by library_search

--  Try this: exact pow_add a b c
\end{minted}
\bigskip

Besides {\verb`library_search`}, {\verb`mathlib`} has a very helpful \href{https://leanprover-community.github.io/contribute/naming.html}{naming convention} that allows you to ``guess'' names of lemmas.
\bigskip
\end{frame}

\begin{frame}[fragile]{{\texttt{simp}}}

As the name suggests, the {\verb`simp`}lifier tries to simplify a goal (or a target hypothesis).

\begin{minted}[mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\small]{Lean}
example {a b : ℤ} : - (-1 * a + 0 * b) = a * (1 + a * 0) :=
begin
  simp,
end
\end{minted}
Here, {\verb`simp`} used the lemmas

\begin{tabular}{|l|l|}
\hline
{\verb`neg_mul`} & {\verb`neg_neg`} \\
{\verb`add_zero`} & \\
{\verb`one_mul`} & {\verb`mul_one`} \\
{\verb`mul_zero`} & {\verb`zero_mul`} \\
\hline
\end{tabular}

\end{frame}

\begin{frame}[fragile]{``{\texttt{simp}}-lemmas'': lemmas that {\texttt{simp}} uses}

\begin{itemize}
\item
  They assert an equality or an iff.
\item
  The LHS {\textbf{looks more complicated}} than the RHS.
\end{itemize}

\begin{minted}[mathescape, numbersep=5pt, frame=lines, framesep=2mm, fontsize=\small]{Lean}
#print one_mul   -- means:   1 * a = a
#print zero_mul  -- means:   0 * a = 0
#print add_zero  -- means:   a + 0 = 0
#print neg_neg   -- means:    - -a = a
#print mul_zero  -- means:   a * 0 = 0
#print mul_one   -- means:   a * 1 = a
#print neg_mul   -- means:  -a * b = -(a * b)
\end{minted}

The asymmetry helps Lean: it flows along
$${\texttt{hard LHS}} \longrightarrow {\texttt{easy RHS}}.$$

\smallskip
\[
  \left[ \;
  \makebox{\parbox{0.8\textwidth}{\small
  Being a ``{\texttt{simp}}-lemma'' is something that {\emph{you}} must communicate to Lean: there is no automated mechanism that makes Lean self-select which lemmas are {\texttt{simp}}-lemmas.
  }}
  \; \right]
\]
\bigskip
\end{frame}
\end{document}
